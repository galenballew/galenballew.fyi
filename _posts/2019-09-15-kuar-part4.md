---
title: 'TL;DR - Kubernetes Up & Running, Part 4'
date: 2019-09-15 00:00:00
excerpt: The saga concludes.
categories: [tldr, cloud]
tags: [gcp, cloud, k8s, aws]
featured_image: '/images/feature/6.jpg'
#scroll_image:
comments: true
share: true
---

# Abstract
These are my notes from reading [_Kubernetes Up & Running_](https://smile.amazon.com/Kubernetes-Running-Dive-Future-Infrastructure/dp/1491935677) by Kelsey Hightower, Brendan Burns, and Joe Beda. Kelsey Hightower is a Staff Developer Advocate for the Google Cloud Platform. Brendan Burns is a Distinguished Engineer in Microsoft Azure and cofounded the Kubernetes project at Google. Joe Beda is the CTO of Heptio and cofounded the Kubernetes project, as well as Google Compute Engine.  

This is a phenomenal book that covers both the whys and hows of [Kubernetes](https://kubernetes.io/). I read the 1st edition, but a 2nd edition is coming out soon. I'm using this as study material for my [CKAD](https://www.cncf.io/certification/ckad/) and [CKA](https://training.linuxfoundation.org/certification/certified-kubernetes-administrator-cka/) certifications.  

This article is part of a series. You can read [Part 1]({{ site.baseurl }}{% link _posts/2019-09-08-kuar-part1.md %}), [Part 2]({{ site.baseurl }}{% link _posts/2019-09-09-kuar-part2.md %}), and [Part 3]({{ site.baseurl }}{% link _posts/2019-09-12-kuar-part3.md %}).

---
## Chapter 12: Deployments
Much like how ReplicaSets manage the Pods beneath them, the `Deployment` object manages ReplicaSets beneath it. Deployments are used to manage the release of new versions and roll those changes out in a simple, reliable fashion. Deployments are a top-level object when compared to ReplicaSets. This means that if you scale a ReplicaSet, the Deployment controller will scale back to the desired state defined in the *Deployment*, not in the ReplicaSet.  

Deployments revolve around their ability to perform a rollout. Rollouts are able to be paused, resumed, and undone. You can undo both partial and completed rollouts. Additionally, the rollout history of a Deployment is retained within the object and you can rollback to a specific version. For Deployments that are long-running, it's a best practice to limit the size of the revision history so that the Deployment object does not become bloated. For example, if you rollout changes every day and you need 2 weeks of revision history, you would set `spec.revisionHistoryLimit` to 14. Undoing a rollout (i.e., rolling back) follows all the same policies as the rollout strategy.  

Because Deployments make it easy to roll back and forth between versions, it is **absolutely paramount** that each version of your application is capable of working interchangeably with both slightly older and slightly newer versions. This backwards and forwards compatibility is critical for decoupled, distributed systems and frequent deployments.  

Deployments can have two different values for `.spec.strategy.type`: `Recreate` or `RollingUpdate`. If `.spec.strategy.type==Recreate`, the Deployment will terminate all Pods associated with it and the associated ReplicaSet will re-create them. This is a fast and simple approach, but results in downtime. It should only be used in testing. `RollingUpdate` is much more sophisticated and is the default configuration. `RollingUpdate` can be configured using 2 different parameters/approaches:
  1. `maxUnavailable`: this parameter can be set as an absolute number or a percentage. If it is set to a value of 1, a single Pod will be terminated and re-created using the new version. After establishing that the Pod is ready, the rollout will proceed to the next Pod. This decreases capacity by the parameter value at any given time.
  2. `maxSurge`: this parameter can be set as an absolute number or a percentage. If it is set to a value of 1, a single Pod will be created using the new version. After establishing that the Pod is ready, *Pod from the previous version will be deleted.* This increases capacity by the parameter value at any given time.  

**Bonus material:** It is not explicitly mentioned in the book, but you can combine these two parameters. In fact, the default setting is 25% for both.  

When performing a rollout, the Deployment controller needs to determine if a Pod is ready before moving on to the next Pod. This means that you *have* to specify readiness checks in your Pod templates. Beyond this, Deployments also support the `minReadSeconds` parameter. This is a waiting period that begins *after* the Pod is marked as ready. `minReadySeconds` can help catch bugs that take a few minutes to show up (e.g., memory leaks). Similar to `minReadSeconds`, the parameter `progressDeadlineSeconds` is used to define a timeout limit for the deployment. It's important to note that this timer is measured by progress, not overall length of the rollout. In this context, progress is defined as any time the deployment creates or deletes a Pod. When that happen, the `progressDeadlineSeconds` timer resets. If the deployment does timeout, it is marked as a failure.  

**Bonus material:** The following is not explained explicitly in the book, but is available in the [documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/).  

Once the deadline has been exceeded, the Deployment controller adds a DeploymentCondition with the following attributes to the Deploymentâ€™s `.status.conditions`:   
```
Type=Progressing
Status=False
Reason=ProgressDeadlineExceeded
```  
**Note:** Kubernetes takes no action on a stalled Deployment other than to report a status condition with `Reason=ProgressDeadlineExceeded`. Higher level orchestrators can take advantage of it and act accordingly, for example, rollback the Deployment to its previous version.

---
## Chapter 13: Integrating Storage Solutions and Kubernetes

---
## Chapter 14: Deploying Real-World Applications

---
# Resources: 
- _Kubernetes Up & Running_ [GitHub repository](https://github.com/kubernetes-up-and-running)
- [Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) - k8s documentation

---
# Continue Reading
- [Part 1]({{ site.baseurl }}{% link _posts/2019-09-08-kuar-part1.md %})
- [Part 2]({{ site.baseurl }}{% link _posts/2019-09-09-kuar-part2.md %})
- [Part 3]({{ site.baseurl }}{% link _posts/2019-09-12-kuar-part3.md %})
- [Part 4]({{ site.baseurl }}{% link _posts/2019-09-15-kuar-part4.md %})